package construct;

public class Basic_Construct {

    public static void main(String[] args) {
        System.out.println("4. 생성자");
        // Tip. Ctrl + P : 파라미터 뭐가 필요한지 띄워줌.
        // Tip. Ctrl + E : 이전 파일로 이동.
        // Tip. Ctrl + B : 메서드 역 추적.
    }
}
/*
    객체를 생성하는 시점에 어떤 작업을 하고 싶다면 생성자(Construct)를 이용하면 된다.
    => 생성자는 객체 생성 직후 객체를 초기화 하기 위한 특별한 메서드로 생각할 수 있다.

    [ this ]
    멤버 변수와 메서드의 매개변수의 이름이 같으면 둘을 어떻게 구분해야 할까?
    - 이 경우 멤버 변수보다 매개변수가 코드 블럭의 더 안쪽에 있기 때문에 매개변수가 우선순위를 가진다.
    - 멤버 변수에 접근하려면 앞에 this. 이라고 해주면 된다.여기서 this는 인스턴스 자신의 참조값을 가리킨다.

    this의 생략: this는 생략할 수 있다. 이 경우 변수를 찾을 때 가까운 지역변수(매개변수도 지역변수다)를 먼저 찾고
    없으면 그 다음으로 멤버 변수를 찾는다. 멤버 변수도 없으면 오류가 발생한다.

    생성자 도입
    프로그래밍을 하다보면 객체를 생성하고 이후에 바로 초기값을 할당해야 하는 경우가 많다.
    따라서 initMember(속성값 할당 메서드)와 같은 메서드를 매번 만들어야 한다.
    그래서 대부분의 객체 지향 언어는 객체를 생성하자마자 즉시 필요한 기능을 좀 더 편리하게 수행할 수 있도록 생성자라는 기능을 제공한다.
    생성자를 사용하면 객체를 생성하는 시점에서 즉시 필요한 기능을 수행할 수 있다.
    생성자는 initMember() 메서드와 유사하지만 몇가지 다른 특징이 있다.

    생성자 장점
    1. 중복 호출 제거: 생성자 덕분에 객체를 생성하면서 동시에 생성 직후에 필요한 작업을 한번에 처리할 수 있게 되었다.
    2. 제약 - 생성자 호출 필수: 객체를 생성할 때 직접 정의한 생성자가 있다면 직접 정의한 생성자를 반드시 호출해야 한다.
       - 직접 정의한 생성자를 호출하지 않으면 컴파일 오류 발생, 아무 정보 없는 유형 회원이 시스템 내부에 등장할 가능성을 원천 차단한다.
       -> 생성자를 사용하면 필수값 입력을 보장할 수 있다.
       * 좋은 프로그램은 무한한 자유도가 주어지는 프로그램이 아니라 적절한 제약이 있는 프로그램이다.*

    기본 생성자
    - 매개변수가 없는 생성자를 기본 생성자라 한다.
    - 클래스에 생성자가 하나도 없으면 자바 컴파일러는 매개변수가 없고, 작동하는 코드가 없는 기본 생성자를 자동으로 만들어준다.
    - 생성자는 하나라도 있으면 자바가 기본 생성자를 만들지 않는다.

    기본 생성자는 왜 자동으로 만들어줄까?
    만약 자바에서 기본 생성자를 만들어주지 않는다면 생성자 기능이 필요하지 않는 경우에도 모든 클래스에 개발자가 직접 기본 생성자를 정의해야 한다.
    생성자 기능을 사용하지 않는 경우도 많기 때문에 이런 편의 기능을 제공한다.
    - 생성자는 반드시 호출되어야 한다.

    생성자도 메서드 오버로딩처럼 매개변수만 다르게 해서 여러 생성자를 제공할 수 있다.

    this()
    - this() 라는 기능을 사용하면 생성자 내부에서 자신의 다른 생성자를 호출할 수 있다.
    - 참고로 this는 인스턴스 자신의 참조값을 가리킨다. 그래서 자신의 생성자를 호출한다고 생각하면 된다.
    - 이를 활용하여 오버로딩 한 생성자 간의 중복을 줄일 수 있다.
    - this() 규칙: this()는 생성자 코드의 첫줄에만 작성할 수 있다.
 */